# 哈希表理论基础

哈希表主要用来判断一个元素是否在集合里

例如要查询一个名字是否在这所学校里。

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

哈希主要有数组，集合和map三种数据结构



# 有效的字母异位词

字符a到字符z的ASCII也是26个连续的数值。如果遇到类似的大小写问题可以定义这个映射的哈希表

| **代码形式**                     | **作用对象 (X)**                               | **实际操作**                                                 |
| -------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `i += 1`                         | 变量 `i`（通常是一个简单的整数变量）。         | **修改变量 `i` 本身的值**。                                  |
| `record[ord(i) - ord("a")] += 1` | **数组 `record` 中由索引确定的那个元素的值**。 | **修改数组中某个格子里的值**，`i` 只是用来计算索引的工具，`i` 本身的值没有改变。 |

```

```

| **特性**       | **for i in range(n)**                                        | **for i in S**                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **迭代对象**   | **`range(n)`** 对象（一个表示 $0$ 到 $n-1$ 整数序列的生成器）。 | **`S`**（可以是列表、字符串、元组、集合、字典等**可迭代对象**）。 |
| **`i` 的含义** | `i` 是序列中的**索引**，从 $0$ 开始递增，直到 $n-1$。        | `i` 是可迭代对象 `S` 中的**实际元素**。                      |
| **用途**       | **需要循环固定次数**，或**需要元素索引**时使用。             | **需要直接访问元素值**，无需索引时使用。                     |
| **示例**       | 遍历 $n$ 次，`i` 依次为 $0, 1, 2, \dots$                     | 遍历 `S` 中所有元素，`i` 依次为元素值。                      |

# 两个数组的交集

**使用数组来做哈希的题目，是因为题目都限制了数值的大小。**如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。这时候可以考虑用set

比如有三个数字 2， 5，100000。这时候数就三个但是数太大了就没必要

| **场景**       | **num 是否在 table 中？** | **table.get(num, 0) 返回什么？**                       | **结果**                                       |
| -------------- | ------------------------- | ------------------------------------------------------ | ---------------------------------------------- |
| **首次出现**   | 否                        | 返回你指定的**默认值 `0`**。                           | 避免了查找不存在的键而导致的 `KeyError` 错误。 |
| **非首次出现** | 是                        | 返回 `num` 当前对应的**计数值**（例如 $1, 2, 3...$）。 | 获取这个数字已经出现的次数。                   |

`record[ord(i) - ord("a")] += 1` 是**针对小写英文字母**的计数方法，因为它可以用一个固定大小的 26 元素的数组。

而 `table[num] = table.get(num, 0) + 1` 是**针对任意整数（或字符串）\**的通用计数方法，因为它使用了\**字典（哈希表）**，它的大小是可变的，可以处理任何范围或类型的键

# 快乐数

关键操作：`divmod(num, 10)` 返回两个值：商和余数

`while n`： 等价于 `while n != 0:` 意思是当n不等于0的时候循环

## 何时选择集合

只关心"某个数字是否已经出现过"，不需要顺序，不需要额外信息，所以用集合

**选择集合当且仅当**：

- ✅ 需要快速查找元素是否存在
- ✅ 不关心元素顺序
- ✅ 不需要存储额外的值（像字典那样）
- ✅ 需要去重
- ✅ 需要集合运算

**不适合用集合**：

- ❌ 需要保持元素顺序 → 用列表
- ❌ 需要关联键值对 → 用字典
- ❌ 需要索引访问 → 用列表

如何判断Class中用不用加self

```c++
class Example:
    def method1(self):  # 类方法，第一个参数必须是 self
        x = 5  # 普通局部变量，不需要 self
        
        def inner_function():  # 内部函数，不是类方法
            return x * 2
        
        result = inner_function()  # ❌ 不需要 self
        result = self.method2()    # ✅ 需要 self，因为 method2 是类方法
        
    def method2(self):  # 类方法
        return "Hello"
```

- **类方法**（在 class 内定义的方法）：定义时需要 `self`，调用时需要 `self.方法名()`
- **普通函数**（在 class 内的函数内定义）：不需要 `self`
- **类的外部函数**：和类无关，不需要 `self`

| 数据结构 | 创建    | 添加元素   | 特点         |
| -------- | ------- | ---------- | ------------ |
| **集合** | `set()` | `add()`    | 不重复，无序 |
| **列表** | `[]`    | `append()` | 可重复，有序 |

列表还有其他添加方法：

```
my_list = [1, 2]

# 在末尾添加
my_list.append(3)     # [1, 2, 3]

# 扩展多个元素
my_list.extend([4, 5]) # [1, 2, 3, 4, 5]

# 在指定位置插入
my_list.insert(0, 0)   # [0, 1, 2, 3, 4, 5]
```

集合也有其他添加方法：

```
my_set = {1, 2}

# 添加单个元素
my_set.add(3)         # {1, 2, 3}

# 添加多个元素
my_set.update([4, 5]) # {1, 2, 3, 4, 5}
```

# 两数之和

**优化思路**：

- 不是"找配对"，而是"问有没有见过我的配对"
- 用字典记住见过的数字和位置

`dict[x] = i`  # 遍历的同时建立索引

这个模式适用于：

- 需要查找配对的场景
- 时间复杂度要求 O(n) 或 O(log n)
- 可以用额外空间优化
- 问题可以转化为"查找是否存在"

# 总结